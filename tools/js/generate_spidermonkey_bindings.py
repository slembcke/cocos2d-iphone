#!/usr/bin/python
# ----------------------------------------------------------------------------
# Simple regular expression that obtains super class and protocols from Obj-C
# interfaces
#
# Author: Ricardo Quesada
# Copyright 2012 (C) Zynga, Inc
#
# Dual License: MIT or GPL v2.
# ----------------------------------------------------------------------------
'''
Obtains 
'''

__docformat__ = 'restructuredtext'


# python
import sys
import os
import re
import getopt
import glob
import ast
import xml.etree.ElementTree as ET
import itertools
import copy
import datetime

BINDINGS_PREFIX = 'js_bindings_'
PROXY_PREFIX = 'JSPROXY_'

#
# Templates
#
autogenerated_template = '''/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by %s on %s
*/
'''

# 1: js_bindindings_CCNode
# 2: JSPROXY_CCNode, 3: JSPROXY_NSObject
# 4: callback code
header_template = '''
#import "%s.h"

/* Proxy class */
@interface %s : %s
{
}
'''

header_template_end = '''
@end
'''

import_template = '''
// needed for callbacks from objective-c to JS
#import <objc/runtime.h>
#import "JRSwizzle.h"

#import "jstypedarray.h"
#import "ScriptingCore.h"   

#import "%s.h"

'''

# 1: JSPROXY_CCNode,
# 2: JSPROXY_CCNode, 3: JSPROXY_CCNode
# 4: CCNode, 5: CCNode
# 6: JSPROXY_CCNode,  7: JSPROXY_CCNode
# 8: possible callback code
constructor_template = ''' // Constructor
JSBool %s_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSObject *jsobj = JS_NewObject(cx, %s_class, %s_object, NULL);
	%s *realObj = [%s alloc];

	%s *proxy = [[%s alloc] initWithJSObject:jsobj andRealObject:realObj];

	[realObj release];

	JS_SetPrivate(jsobj, proxy);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	%s
	
	return JS_TRUE;
}
'''


# 1: JSPROXY_CCNode,
# 2: JSPROXY_CCNode, 3: JSPROXY_CCNode
# 4: possible callback code
destructor_template = '''
// Destructor
void %s_finalize(JSContext *cx, JSObject *obj)
{
	%s *pt = (%s*)JS_GetPrivate(obj);
	if (pt) {
		id real = [pt realObj];
	
	%s

		[real release];
	
		[pt release];

		JS_free(cx, pt);
	}
}
'''


# xml2d recipe copied from here:
# http://code.activestate.com/recipes/577722-xml-to-python-dictionary-and-back/
def xml2d(e):
    """Convert an etree into a dict structure

    @type  e: etree.Element
    @param e: the root of the tree
    @return: The dictionary representation of the XML tree
    """
    def _xml2d(e):
        kids = dict(e.attrib)
        for k, g in itertools.groupby(e, lambda x: x.tag):
            g = [ _xml2d(x) for x in g ] 
            kids[k]=  g
        return kids
    return { e.tag : _xml2d(e) }


class SpiderMonkey(object):
    def __init__(self, bridgesupport_file, hierarchy_file, classes_to_bind=[] ):
        self.bridgesupport_file = bridgesupport_file
        self.bs = {}

        self.hierarchy_file = hierarchy_file
        self.hierarchy = {}
        
        self.classes_to_bind = set(classes_to_bind)

    def parse_hierarchy_file( self ):
        f = open( self.hierarchy_file )
        self.hierarchy = ast.literal_eval( f.read() )
        f.close()

    def parse_bridgesupport_file( self ):
        p = ET.parse( self.bridgesupport_file )
        root = p.getroot()
        self.bs = xml2d( root )

    def ancestors( self, klass, list_of_ancestors ):
        if klass not in self.hierarchy:
            return list_of_ancestors

        info = self.hierarchy[ klass ]
        subclass =  info['subclass']
        if not subclass:
            return list_of_ancestors

        list_of_ancestors.append( subclass )

        return self.ancestors( subclass, list_of_ancestors )


    def generate_class_binding( self, class_name ):

        h_file = open( '%s%s.h' % ( BINDINGS_PREFIX, class_name), 'w' )
        mm_file = open( '%s%s.mm' % (BINDINGS_PREFIX, class_name), 'w' )

        signatures = self.bs['signatures']
        classes = signatures['class']
        klass = None

        parent_name = self.hierarchy[ class_name ]['subclass']

        # XXX: Super slow. Add them into a dictionary
        for c in classes:
            if c['name'] == class_name:
                klass = c
                break

        methods = klass['method']
        for m in methods:
            print m['selector']

        proxy_class_name = '%s%s' % (PROXY_PREFIX, class_name )

        # Header file
        h_file.write( autogenerated_template % ( sys.argv[0], datetime.date.today() ) )
        h_file.write( header_template % (  BINDINGS_PREFIX + class_name, proxy_class_name, PROXY_PREFIX + parent_name  ) )
        # callback code should be added here
        h_file.write( header_template_end )

        # Implementation file
        mm_file.write( autogenerated_template % ( sys.argv[0], datetime.date.today() ) )
        mm_file.write( import_template % (BINDINGS_PREFIX+class_name) )
        mm_file.write( constructor_template % ( proxy_class_name, proxy_class_name, proxy_class_name, class_name, class_name, proxy_class_name, proxy_class_name, '/* no callbacks */' ) )

        h_file.close()
        mm_file.close()

    def generate_bindings( self ):
        ancestors = []
        for klass in self.classes_to_bind:
            new_list = self.ancestors( klass, [klass] )      
            ancestors.extend( new_list )

        s = set(ancestors)

        # Explicity remove NSObject. It is generated manually
        copy_set = copy.copy(s)
        for i in copy_set:
            if i.startswith('NS'):
                print 'Removing %s from bindings...' % i
                s.remove( i )

        for klass in s:
            self.generate_class_binding( klass )

    def parse( self ):
        self.parse_hierarchy_file()
        self.parse_bridgesupport_file()

        self.generate_bindings()

def help():
    print "%s v1.0 - An utility to generate SpiderMonkey JS bindings for BridgeSupport files" % sys.argv[0]
    print "Usage:"
    print "\t-b --bridgesupport\tBridgesupport file to parse"
    print "\t-j --hierarchy\tFile that contains the hierarchy class and used protocols"
    print "{class to parse}\tName of the classes to generate. If no classes are "
    print "\nExample:"
    print "\t%s -b cocos2d-mac.bridgesupport -j cocos2d-mac_hierarchy.txt CCNode CCSprite" % sys.argv[0]
    sys.exit(-1)

if __name__ == "__main__":
    if len( sys.argv ) == 1:
        help()

    bridgesupport_file = None
    hierarchy_file = None

    argv = sys.argv[1:]
    try:                                
        opts, args = getopt.getopt(argv, "b:j:", ["bridgesupport=","hierarchy="])

        for opt, arg in opts:
            if opt in ("-b","--bridgesupport"):
                bridgesupport_file = arg
            if opt in  ("-j", "--hierarchy"):
                hierarchy_file = arg
    except getopt.GetoptError,e:
        print e
        opts, args = getopt.getopt(argv, "", [])

    if args == None:
        help()

    instance = SpiderMonkey(bridgesupport_file, hierarchy_file, args )
    instance.parse()

