/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by ../../tools/js/generate_spidermonkey_bindings.py on 2012-06-20
*/

#import "jstypedarray.h"
#import "ScriptingCore.h"
#import "js_manual_conversions.h"
#import "js_bindings_chipmunk_functions.h"

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpAreaForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpAreaForCircle((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpAreaForSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpAreaForSegment((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpBBArea(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpBBArea((cpBB)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBBClampVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBBClampVect((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
JSBool JSPROXY_cpBBContainsBB(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBContainsBB((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpBBContainsVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBContainsVect((cpBB)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpBB
JSBool JSPROXY_cpBBExpand(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBB ret_val;

	ret_val = cpBBExpand((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
JSBool JSPROXY_cpBBIntersects(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBIntersects((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpBBIntersectsSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; cpVect arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpBool ret_val;

	ret_val = cpBBIntersectsSegment((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBB
JSBool JSPROXY_cpBBMerge(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBB ret_val;

	ret_val = cpBBMerge((cpBB)arg0 , (cpBB)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpBBMergedArea(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpBBMergedArea((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpFloat
// Ret value: cpBB
JSBool JSPROXY_cpBBNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; double arg3; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	JS_ValueToNumber( cx, *argvp++, &arg3 );
	cpBB ret_val;

	ret_val = cpBBNew((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpBB
JSBool JSPROXY_cpBBNewForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpBB ret_val;

	ret_val = cpBBNewForCircle((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpBBSegmentQuery(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; cpVect arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpFloat ret_val;

	ret_val = cpBBSegmentQuery((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBBWrapVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBBWrapVect((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodyActivate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodyActivate((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpShape*
// Ret value: None
JSBool JSPROXY_cpBodyActivateStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpShape* arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpBodyActivateStatic((cpBody*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSPROXY_cpBodyAlloc(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );
	cpBody* ret_val;

	ret_val = cpBodyAlloc( );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: None
JSBool JSPROXY_cpBodyApplyForce(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);

	cpBodyApplyForce((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: None
JSBool JSPROXY_cpBodyApplyImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);

	cpBodyApplyImpulse((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodyDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodyDestroy((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodyFree(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodyFree((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetAngVel((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetAngVelLimit((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetAngle((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetForce(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpBodyGetForce((cpBody*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetMass((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetMoment((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetPos(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpBodyGetPos((cpBody*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetRot(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpBodyGetRot((cpBody*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpSpace*
JSBool JSPROXY_cpBodyGetSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpSpace* ret_val;

	ret_val = cpBodyGetSpace((cpBody*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetTorque((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetVel(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpBodyGetVel((cpBody*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetVelAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBodyGetVelAtLocalPoint((cpBody*)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBodyGetVelAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBodyGetVelAtWorldPoint((cpBody*)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyGetVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyGetVelLimit((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat, cpFloat
// Ret value: cpBody*
JSBool JSPROXY_cpBodyInit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; double arg2; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpBody* ret_val;

	ret_val = cpBodyInit((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpBody*
JSBool JSPROXY_cpBodyInitStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBody* ret_val;

	ret_val = cpBodyInitStatic((cpBody*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpBool
JSBool JSPROXY_cpBodyIsRogue(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpBodyIsRogue((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpBool
JSBool JSPROXY_cpBodyIsSleeping(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpBodyIsSleeping((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpBool
JSBool JSPROXY_cpBodyIsStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpBodyIsStatic((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpFloat
JSBool JSPROXY_cpBodyKineticEnergy(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpBodyKineticEnergy((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBodyLocal2World(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBodyLocal2World((cpBody*)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpBody*
JSBool JSPROXY_cpBodyNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpBody* ret_val;

	ret_val = cpBodyNew((cpFloat)arg0 , (cpFloat)arg1  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSPROXY_cpBodyNewStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );
	cpBody* ret_val;

	ret_val = cpBodyNewStatic( );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodyResetForces(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodyResetForces((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodySanityCheck(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodySanityCheck((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetAngVel((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetAngVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetAngle((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: None
JSBool JSPROXY_cpBodySetForce(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	cpBodySetForce((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetMass((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetMoment((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: None
JSBool JSPROXY_cpBodySetPos(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	cpBodySetPos((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetTorque((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: None
JSBool JSPROXY_cpBodySetVel(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	cpBodySetVel((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodySetVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodySetVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: None
JSBool JSPROXY_cpBodySleep(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodySleep((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpBody*
// Ret value: None
JSBool JSPROXY_cpBodySleepWithGroup(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpBody* arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpBodySleepWithGroup((cpBody*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodyUpdatePosition(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpBodyUpdatePosition((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect, cpFloat, cpFloat
// Ret value: None
JSBool JSPROXY_cpBodyUpdateVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; double arg2; double arg3; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	JS_ValueToNumber( cx, *argvp++, &arg3 );

	cpBodyUpdateVelocity((cpBody*)arg0 , (cpVect)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBodyWorld2Local(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBodyWorld2Local((cpBody*)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat, cpFloat
// Ret value: cpShape*
JSBool JSPROXY_cpBoxShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; double arg2; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpShape* ret_val;

	ret_val = cpBoxShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpBody*, cpBB
// Ret value: cpShape*
JSBool JSPROXY_cpBoxShapeNew2(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpBB arg1; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpShape* ret_val;

	ret_val = cpBoxShapeNew2((cpBody*)arg0 , (cpBB)arg1  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpVect
JSBool JSPROXY_cpCircleShapeGetOffset(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpCircleShapeGetOffset((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpFloat
JSBool JSPROXY_cpCircleShapeGetRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpCircleShapeGetRadius((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*, cpFloat, cpVect
// Ret value: cpShape*
JSBool JSPROXY_cpCircleShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; double arg1; cpVect arg2; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpShape* ret_val;

	ret_val = cpCircleShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpVect)arg2  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: None
JSBool JSPROXY_cpInitChipmunk(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );

	cpInitChipmunk( );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForBox(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpMomentForBox((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForBox2(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; cpBB arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpMomentForBox2((cpFloat)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; cpVect arg3; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(cpVect*)JS_GetTypedArrayData( tmp_arg3);
	cpFloat ret_val;

	ret_val = cpMomentForCircle((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpVect)arg3  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; cpVect arg1; cpVect arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpFloat ret_val;

	ret_val = cpMomentForSegment((cpFloat)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: int
JSBool JSPROXY_cpPolyShapeGetNumVerts(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	int ret_val;

	ret_val = cpPolyShapeGetNumVerts((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*, int
// Ret value: cpVect
JSBool JSPROXY_cpPolyShapeGetVert(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; int32_t arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpPolyShapeGetVert((cpShape*)arg0 , (int)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: None
JSBool JSPROXY_cpResetShapeIdCounter(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );

	cpResetShapeIdCounter( );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpVect
JSBool JSPROXY_cpSegmentShapeGetA(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpSegmentShapeGetA((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpVect
JSBool JSPROXY_cpSegmentShapeGetB(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpSegmentShapeGetB((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpVect
JSBool JSPROXY_cpSegmentShapeGetNormal(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpSegmentShapeGetNormal((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpFloat
JSBool JSPROXY_cpSegmentShapeGetRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSegmentShapeGetRadius((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*, cpVect, cpVect, cpFloat
// Ret value: cpShape*
JSBool JSPROXY_cpSegmentShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBody* arg0; cpVect arg1; cpVect arg2; double arg3; 

	arg0 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	JS_ValueToNumber( cx, *argvp++, &arg3 );
	cpShape* ret_val;

	ret_val = cpSegmentShapeNew((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2 , (cpFloat)arg3  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpShape*, cpVect, cpVect
// Ret value: None
JSBool JSPROXY_cpSegmentShapeSetNeighbors(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; cpVect arg1; cpVect arg2; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);

	cpSegmentShapeSetNeighbors((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpBB
JSBool JSPROXY_cpShapeCacheBB(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpBB ret_val;

	ret_val = cpShapeCacheBB((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: None
JSBool JSPROXY_cpShapeDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpShapeDestroy((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: None
JSBool JSPROXY_cpShapeFree(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpShapeFree((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpBB
JSBool JSPROXY_cpShapeGetBB(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpBB ret_val;

	ret_val = cpShapeGetBB((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpBody*
JSBool JSPROXY_cpShapeGetBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpBody* ret_val;

	ret_val = cpShapeGetBody((cpShape*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpFloat
JSBool JSPROXY_cpShapeGetElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpShapeGetElasticity((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpFloat
JSBool JSPROXY_cpShapeGetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpShapeGetFriction((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpLayers
JSBool JSPROXY_cpShapeGetLayers(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpLayers ret_val;

	ret_val = cpShapeGetLayers((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpBool
JSBool JSPROXY_cpShapeGetSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpShapeGetSensor((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpSpace*
JSBool JSPROXY_cpShapeGetSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpSpace* ret_val;

	ret_val = cpShapeGetSpace((cpShape*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpVect
JSBool JSPROXY_cpShapeGetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpShapeGetSurfaceVelocity((cpShape*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpShape*, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpShapePointQuery(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; cpVect arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpShapePointQuery((cpShape*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*, cpBody*
// Ret value: None
JSBool JSPROXY_cpShapeSetBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; cpBody* arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpShapeSetBody((cpShape*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpFloat
// Ret value: None
JSBool JSPROXY_cpShapeSetElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; double arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpShapeSetElasticity((cpShape*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpFloat
// Ret value: None
JSBool JSPROXY_cpShapeSetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; double arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpShapeSetFriction((cpShape*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpLayers
// Ret value: None
JSBool JSPROXY_cpShapeSetLayers(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; uint32_t arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAUint32( cx, *argvp++, &arg1 );

	cpShapeSetLayers((cpShape*)arg0 , (cpLayers)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpBool
// Ret value: None
JSBool JSPROXY_cpShapeSetSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; int32_t arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAInt32( cx, *argvp++, &arg1 );

	cpShapeSetSensor((cpShape*)arg0 , (cpBool)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpVect
// Ret value: None
JSBool JSPROXY_cpShapeSetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; cpVect arg1; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	cpShapeSetSurfaceVelocity((cpShape*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpShape*, cpVect, cpVect
// Ret value: cpBB
JSBool JSPROXY_cpShapeUpdate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpShape* arg0; cpVect arg1; cpVect arg2; 

	arg0 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpBB ret_val;

	ret_val = cpShapeUpdate((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: None
JSBool JSPROXY_cpSpaceActivateShapesTouchingShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceActivateShapesTouchingShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpBody*
// Ret value: cpBody*
JSBool JSPROXY_cpSpaceAddBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpBody* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBody* ret_val;

	ret_val = cpSpaceAddBody((cpSpace*)arg0 , (cpBody*)arg1  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: cpShape*
JSBool JSPROXY_cpSpaceAddShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpShape* ret_val;

	ret_val = cpSpaceAddShape((cpSpace*)arg0 , (cpShape*)arg1  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: cpShape*
JSBool JSPROXY_cpSpaceAddStaticShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpShape* ret_val;

	ret_val = cpSpaceAddStaticShape((cpSpace*)arg0 , (cpShape*)arg1  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSPROXY_cpSpaceAlloc(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );
	cpSpace* ret_val;

	ret_val = cpSpaceAlloc( );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*, cpBody*
// Ret value: cpBool
JSBool JSPROXY_cpSpaceContainsBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpBody* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpSpaceContainsBody((cpSpace*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: cpBool
JSBool JSPROXY_cpSpaceContainsShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpSpaceContainsShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: None
JSBool JSPROXY_cpSpaceDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceDestroy((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: None
JSBool JSPROXY_cpSpaceFree(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceFree((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionBias((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpTimestamp
JSBool JSPROXY_cpSpaceGetCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpTimestamp ret_val;

	ret_val = cpSpaceGetCollisionPersistence((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionSlop((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetCurrentTimeStep(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetCurrentTimeStep((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetDamping((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpBool
JSBool JSPROXY_cpSpaceGetEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpSpaceGetEnableContactGraph((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpVect
JSBool JSPROXY_cpSpaceGetGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpVect ret_val;

	ret_val = cpSpaceGetGravity((cpSpace*)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetIdleSpeedThreshold((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: int
JSBool JSPROXY_cpSpaceGetIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	int ret_val;

	ret_val = cpSpaceGetIterations((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpFloat
JSBool JSPROXY_cpSpaceGetSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpFloat ret_val;

	ret_val = cpSpaceGetSleepTimeThreshold((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpBody*
JSBool JSPROXY_cpSpaceGetStaticBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpBody* ret_val;

	ret_val = cpSpaceGetStaticBody((cpSpace*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpSpace*
JSBool JSPROXY_cpSpaceInit(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpSpace* ret_val;

	ret_val = cpSpaceInit((cpSpace*)arg0  );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: cpBool
JSBool JSPROXY_cpSpaceIsLocked(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	cpBool ret_val;

	ret_val = cpSpaceIsLocked((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSPROXY_cpSpaceNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );
	cpSpace* ret_val;

	ret_val = cpSpaceNew( );

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: None
JSBool JSPROXY_cpSpaceReindexShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceReindexShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpBody*
// Ret value: None
JSBool JSPROXY_cpSpaceReindexShapesForBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpBody* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceReindexShapesForBody((cpSpace*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*
// Ret value: None
JSBool JSPROXY_cpSpaceReindexStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceReindexStatic((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpBody*
// Ret value: None
JSBool JSPROXY_cpSpaceRemoveBody(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpBody* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpBody*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceRemoveBody((cpSpace*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: None
JSBool JSPROXY_cpSpaceRemoveShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceRemoveShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpShape*
// Ret value: None
JSBool JSPROXY_cpSpaceRemoveStaticShape(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpShape* arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	arg1 = (cpShape*) jsval_to_opaque( cx, *argvp++ );

	cpSpaceRemoveStaticShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceSetCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceSetCollisionBias((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpTimestamp
// Ret value: None
JSBool JSPROXY_cpSpaceSetCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; uint32_t arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAUint32( cx, *argvp++, &arg1 );

	cpSpaceSetCollisionPersistence((cpSpace*)arg0 , (cpTimestamp)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceSetCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceSetCollisionSlop((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceSetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceSetDamping((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpBool
// Ret value: None
JSBool JSPROXY_cpSpaceSetEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; int32_t arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAInt32( cx, *argvp++, &arg1 );

	cpSpaceSetEnableContactGraph((cpSpace*)arg0 , (cpBool)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpVect
// Ret value: None
JSBool JSPROXY_cpSpaceSetGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; cpVect arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	cpSpaceSetGravity((cpSpace*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceSetIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceSetIdleSpeedThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, int
// Ret value: None
JSBool JSPROXY_cpSpaceSetIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; int32_t arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToECMAInt32( cx, *argvp++, &arg1 );

	cpSpaceSetIterations((cpSpace*)arg0 , (int)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceSetSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceSetSleepTimeThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat
// Ret value: None
JSBool JSPROXY_cpSpaceStep(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );

	cpSpaceStep((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpSpace*, cpFloat, int
// Ret value: None
JSBool JSPROXY_cpSpaceUseSpatialHash(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpSpace* arg0; double arg1; int32_t arg2; 

	arg0 = (cpSpace*) jsval_to_opaque( cx, *argvp++ );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToECMAInt32( cx, *argvp++, &arg2 );

	cpSpaceUseSpatialHash((cpSpace*)arg0 , (cpFloat)arg1 , (int)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfabs(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpFloat ret_val;

	ret_val = cpfabs((cpFloat)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpfclamp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfclamp01(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpFloat ret_val;

	ret_val = cpfclamp01((cpFloat)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpflerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpflerp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpflerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpflerpconst((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfmax(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpfmax((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfmin(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpfmin((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpv(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpv((cpFloat)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvadd(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvadd((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpvclamp((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvcross(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvcross((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdist(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdist((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdistsq(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdistsq((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdot(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdot((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpveql(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpveql((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvforangle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpVect ret_val;

	ret_val = cpvforangle((cpFloat)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvlength(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvlength((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvlengthsq(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvlengthsq((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvlerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvlerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvlerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvlerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvmult(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpvmult((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpBool
JSBool JSPROXY_cpvnear(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpBool ret_val;

	ret_val = cpvnear((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvneg(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvneg((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvnormalize(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvnormalize((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvnormalize_safe(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvnormalize_safe((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvperp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvperp((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvproject(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvproject((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvrotate((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvrperp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvrperp((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvslerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvslerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvslerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvslerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvsub(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvsub((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvtoangle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvtoangle((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvunrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvunrotate((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 2 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}
