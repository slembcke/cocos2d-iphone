/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by ../../tools/js/generate_spidermonkey_bindings.py on 2012-06-19
*/

#import "jstypedarray.h"
#import "ScriptingCore.h"
#import "js_manual_conversions.h"
#import "js_bindings_chipmunk_functions.h"

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpAreaForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpAreaForCircle((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpAreaForSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpAreaForSegment((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpBBArea(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpBBArea((cpBB)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBBClampVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBBClampVect((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
JSBool JSPROXY_cpBBContainsBB(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBContainsBB((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpBBContainsVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBContainsVect((cpBB)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpBB
JSBool JSPROXY_cpBBExpand(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBB ret_val;

	ret_val = cpBBExpand((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 5 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
JSBool JSPROXY_cpBBIntersects(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpBBIntersects((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpBBIntersectsSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; cpVect arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpBool ret_val;

	ret_val = cpBBIntersectsSegment((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpBB
JSBool JSPROXY_cpBBMerge(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpBB ret_val;

	ret_val = cpBBMerge((cpBB)arg0 , (cpBB)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 5 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpBBMergedArea(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpBB arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpBBMergedArea((cpBB)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpFloat
// Ret value: cpBB
JSBool JSPROXY_cpBBNew(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; double arg3; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	JS_ValueToNumber( cx, *argvp++, &arg3 );
	cpBB ret_val;

	ret_val = cpBBNew((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 5 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpBB
JSBool JSPROXY_cpBBNewForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpBB ret_val;

	ret_val = cpBBNewForCircle((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 5 );
	cpBB* buffer = (cpBB*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpBBSegmentQuery(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; cpVect arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpFloat ret_val;

	ret_val = cpBBSegmentQuery((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpBBWrapVect(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpBB arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpBB*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpBBWrapVect((cpBB)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: None
JSBool JSPROXY_cpInitChipmunk(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );

	cpInitChipmunk( );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForBox(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpMomentForBox((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpBB
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForBox2(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; cpBB arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpBB*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpMomentForBox2((cpFloat)arg0 , (cpBB)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 4, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; cpVect arg3; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(cpVect*)JS_GetTypedArrayData( tmp_arg3);
	cpFloat ret_val;

	ret_val = cpMomentForCircle((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpVect)arg3  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpMomentForSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; cpVect arg1; cpVect arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);

	JSObject *tmp_arg2;
	JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(cpVect*)JS_GetTypedArrayData( tmp_arg2);
	cpFloat ret_val;

	ret_val = cpMomentForSegment((cpFloat)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: None
JSBool JSPROXY_cpResetShapeIdCounter(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 0, @"Invalid number of arguments" );

	cpResetShapeIdCounter( );
	JS_SET_RVAL(cx, vp, JSVAL_TRUE);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfabs(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpFloat ret_val;

	ret_val = cpfabs((cpFloat)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpfclamp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfclamp01(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpFloat ret_val;

	ret_val = cpfclamp01((cpFloat)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpflerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpflerp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpflerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; double arg2; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpFloat ret_val;

	ret_val = cpflerpconst((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfmax(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpfmax((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
JSBool JSPROXY_cpfmin(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpFloat ret_val;

	ret_val = cpfmin((cpFloat)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpv(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; double arg1; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpv((cpFloat)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvadd(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvadd((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpvclamp((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvcross(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvcross((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdist(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdist((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdistsq(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdistsq((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvdot(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpFloat ret_val;

	ret_val = cpvdot((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpBool
JSBool JSPROXY_cpveql(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpBool ret_val;

	ret_val = cpveql((cpVect)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvforangle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	double arg0; 

	JS_ValueToNumber( cx, *argvp++, &arg0 );
	cpVect ret_val;

	ret_val = cpvforangle((cpFloat)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvlength(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvlength((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvlengthsq(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvlengthsq((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvlerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvlerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvlerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvlerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvmult(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; double arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	JS_ValueToNumber( cx, *argvp++, &arg1 );
	cpVect ret_val;

	ret_val = cpvmult((cpVect)arg0 , (cpFloat)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpBool
JSBool JSPROXY_cpvnear(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpBool ret_val;

	ret_val = cpvnear((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvneg(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvneg((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvnormalize(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvnormalize((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvnormalize_safe(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvnormalize_safe((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvperp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvperp((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvproject(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvproject((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvrotate((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvrperp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpVect ret_val;

	ret_val = cpvrperp((cpVect)arg0  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvslerp(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvslerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
JSBool JSPROXY_cpvslerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 3, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; double arg2; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	JS_ValueToNumber( cx, *argvp++, &arg2 );
	cpVect ret_val;

	ret_val = cpvslerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvsub(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvsub((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpFloat
JSBool JSPROXY_cpvtoangle(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 1, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);
	cpFloat ret_val;

	ret_val = cpvtoangle((cpVect)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
JSBool JSPROXY_cpvunrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	NSCAssert( argc == 2, @"Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	cpVect arg0; cpVect arg1; 


	JSObject *tmp_arg0;
	JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(cpVect*)JS_GetTypedArrayData( tmp_arg0);

	JSObject *tmp_arg1;
	JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(cpVect*)JS_GetTypedArrayData( tmp_arg1);
	cpVect ret_val;

	ret_val = cpvunrotate((cpVect)arg0 , (cpVect)arg1  );

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	cpVect* buffer = (cpVect*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}
