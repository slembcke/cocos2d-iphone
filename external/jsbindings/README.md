# Javascript Bindings for C and Objective-C

version 0.1

## What's this ?
JavaScript Bindings for C / Objective-C (JSB) is the "glue" code (or wrapper code) that sits between native code (C or Objective-C) and JavaScript (JS) code.
JSB allows calling native code from JS and vice-versa.

![JSB layer](docs/jsb_intro.png)

The JS code is interpreted by [SpiderMonkey](https://developer.mozilla.org/en-US/docs/SpiderMonkey), Mozilla's JS virtual machine (VM).
It uses the latest stable version of SpiderMonkey (as of this writing it is v14.0.1). The JS VM is extended by JSB to support custom types, custom structures and Objective-C objects.

JSB has a flexible set of rules that could be used to select the classes, methods, functions and structs to parse or ignore; which methods are callbacks; renaming rules, among some of its features. And to ease the creation of these rules, it supports regular expressions.

JSB could be used in complex libraries like [cocos2d](http://www.cocos2d-iphone.org) or [Chipmunk Physics](http://www.chipmunk-physics.net), without modifying the a single line of their code.

## How does it work ?

JSB comes with a python script called `generate_js_bindings.py` that generates the glue code. It needs a configuration file that contains the parsing rules and the [BridgeSupport](http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man5/BridgeSupport.5.html) files.

BridgeSupport files are generated by a script called [`gen_bridge_metada`](http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/gen_bridge_metadata.1.html#//apple_ref/doc/man/1/gen_bridge_metadata) that is part of OS X, and generates xml files with information like class names, method names, arguments, return values, internals of the structs, constants, etc. 

`gen_bridge_metada`, internally, uses [`clang`](http://clang.llvm.org/) to parse the native code. The output is very reliable, but unfortunately, it is not complete: class hierarchy, protocols and properties data is missing. That's why JSB comes with another python script, called `generate_js_complement.py`, that generates the missing information.

Once we have the configuration file setup, we can run the `generate_js_bindings.py` script to generate the glue code.

To summarize, the structure of a JSB configuration file is:

- Parsing rules (optional): renaming rules, classes to ignore/parse, etc...
- BridgeSupport files (required): Class, methods, functions, structs information
- Complement files (required for Objective-C projects): Hierarchy, protocol and properties information

!["glue" code generation](docs/jsb_files.png)



## Internals of the JS bindings ("glue" code)

The JS bindings code allows to call JS code from native and vice-versa. It fowards native callbacks to JS. It supports "subclassing" native objects in JS. Let's see them in detail.

### Calling native code from JS

The following code will execute 10 times the the native C function `ccpAdd()`:

	var p = cc.p(0,0);
	var q = cc.p(1,1);
	for( var i=0; i < 10; i++)
		p = cc.pAdd(p, q);   // cc.pAdd is a "wrapped" function, and it will call the cocos2d ccpAdd() C function


Let's take a look at the declaration of `ccpAdd`:

	CGPoint ccpAdd(const CGPoint v1, const CGPoint v2);

So when `cc.pAdd` is executed, it will call the "glue" code function code `JSPROXY_ccpAdd`. `JSPROXY_ccpAdd` is responsible for doing:

- convert the arguments from JS to native
- call `ccpAdd()`
- convert the return value from native to JS
- and report in case there is a problem converting the arguments or return value.

`cc.pAdd` receives to arguments: `p` and `q` which are JS objects. The proxy function `JSPROXY_ccpAdd` will be called. It will convert the 2 arguments into `CGPoint` structs, and call `ccpAdd`. The return value will be a `CGPoint`. `JSPROXY_ccpAdd` will convert the `CGPoint` into a valid JS Object, and return the newly created object into JS.


### Classes

JSB also works with Objective-C objects. Example:

	var sprite = cc.Sprite.create("grossini.png"); // Creates a native cocos2d CCSprite (a native object);
	sprite.setPosition( cc.p(10,10) );  // sends the message "setPosition" to the newly created instance


### Arguments

JSB converts any Javascript arguments into valid native objects. In this case, the "sprite" argument is converted from a Javascript object into a CCSprite object.

	var scene = cc.Scene.create();  // creates a cocos2d CCScene object.
	scene.addChild( sprite );   // sends the "addChild" message to the scene.


### Messages

JSB can also merge multiple messages into one. Objective-C doesn't support optional arguments, but Javascript does. So it is possible to merge multiple messages into one. Example:

	-(void) addChild:(CCNode*)node;
	-(void) addChild:(CCNode*)node z:(NSInteger)z;
	-(void) addChild:(CCNode*)node z:(NSInteger)z tag:(NSInteger)tag;

can be merged into just one Javascript call. Example:

	scene.addChild( sprite );        // calls  addChild:
	scene.addChild( sprite, 10);     // calls  addChild:z:
	scene.addChild( sprite, 10, -1); // calls  addChild:z:tag: 


## Generating the bindigns

    $ cd cocos2d-iphone/externals/jsbindings/src/auto
    $ ../../generate_js_bindings.py -c ../../configs/cocos2d/cocos2d_jsb.ini 
    $ ../../generate_js_bindings.py -c ../../configs/chipmunk/chipmunk_jsb.ini 
    $ ../../generate_js_bindings.py -c ../../configs/CocosBuilderReader/CocosBuilderReader_jsb.ini 
    $ ../../generate_js_bindings.py -c ../../configs/CocosDenshion/CocosDenshion_jsb.ini 

