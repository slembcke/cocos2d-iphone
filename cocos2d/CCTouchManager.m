/*
 * cocos2d for iPhone: http://www.cocos2d-iphone.org
 *
 * Copyright (c) 2010 Ricardo Quesada
 * Copyright (c) 2011 Zynga Inc.
 * Copyright (c) 2013 Lars Birkemose
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * File autogenerated with Xcode. Adapted for cocos2d needs.
 */

#import "CCTouchManager.h"
#import "CCNode.h"
#import "CCDirector.h"
#import "CCScene.h"

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouch

@end

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouchManager {
    __weak CCNode*          _responderList[ CCTouchManagerTouchBufferSize ];
    int                     _responderCount;
    NSMutableArray*         _touchList;                             // list of running touches
}

// -----------------------------------------------------------------
#pragma mark - create and destroy
// -----------------------------------------------------------------

+( id )touchManager {
    return( [ [ self alloc ] init ] );
}

-( id )init {
    self = [ super init ];
    NSAssert( self != nil, @"Unable to create class" );
    
    // initalize
    _touchList = [ NSMutableArray array ];
        
    // reset touch handling
    [ self removeAllTouchResponders ];
    
    // done
    return( self );
}

// -----------------------------------------------------------------
#pragma mark - add and remove touch responders
// -----------------------------------------------------------------

-( void )addTouchResponder:( CCNode* )responder {
    
    _responderList[ _responderCount ] = responder;
    _responderCount ++;
    NSAssert( _responderCount < CCTouchManagerTouchBufferSize, @"Number of touchable nodes pr. scene can not exceed <%d>", CCTouchManagerTouchBufferSize );
}

-( void )removeAllTouchResponders {
    
    _responderCount = 0;
}

// -----------------------------------------------------------------
#pragma mark - touch handling
// -----------------------------------------------------------------

-( void )touchesBegan:( NSSet* )touches withEvent:( UIEvent* )event {
    BOOL responderCanNotAcceptTouch;
    
    [ self buildTouchResponderList ];
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // scan backwards through touch responders
        for ( int index = _responderCount - 1; index >= 0; index -- ) {
            CCNode* node = _responderList[ index ];
            
            // check for hit test
            if ( [ node hitTestWithTouch:touch ] == YES ) {
                
                // if not a multi touch node, check if node already is being touched
                responderCanNotAcceptTouch = NO;
                if ( node.isMultipleTouchEnabled == NO ) {
                
                    // scan current touch objects, and break if object already has a touch
                    for ( CCTouch* touchEntry in _touchList ) if ( touchEntry.node == node ) {
                        responderCanNotAcceptTouch = YES;
                        break;
                    }
                }                
                if ( responderCanNotAcceptTouch == YES ) break;
                
                // begin the touch
                self.touchProcessed = YES;
                NSLog( @"Began with <%d> touch responder(s)", _touchList.count );
                if ( [ node respondsToSelector:@selector( touchesBegan:withEvent: ) ] == YES )
                    [ node touchesBegan:[ NSSet setWithObject:touch ] withEvent:event ];
 
                // if touch was processed, add it and break
                if ( self.touchProcessed == YES ) {
                    
                    [ self addtouchResponder:node withTouch:touch andEvent:event ];
                    break;
                }
            }
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesMoved:( NSSet* )touches withEvent:( UIEvent* )event {
    
    [ self buildTouchResponderList ];

    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouch* touchEntry = [ self touchResponderForEvent:event ];
        
        // if a touch object was found
        if ( touchEntry != nil ) {
            
            // check if it locks touches
            if ( touchEntry.node.isTouchLocked == YES ) {
                
                // move the touch
                NSLog( @"Moved with <%d> touch responder(s)", _touchList.count );
                if ( [ touchEntry.node respondsToSelector:@selector( touchesMoved:withEvent: ) ] == YES )
                    [ touchEntry.node touchesMoved:[ NSSet setWithObject:touch ] withEvent:event ];
                
            } else {
            
                // as node does not lock touch, check if it was moved outside
                if ( [ touchEntry.node hitTestWithTouch:touch ] == NO ) {
                
                    // cancel the touch
                    NSLog( @"Cancelled with <%d> touch responder(s)", _touchList.count );
                    if ( [ touchEntry.node respondsToSelector:@selector( touchesCancelled:withEvent: ) ] == YES )
                        [ touchEntry.node touchesCancelled:[ NSSet setWithObject:touch ] withEvent:event ];
                    // remove from list
                    [ _touchList removeObject:touchEntry ];
                
                } else {
                
                    // move the touch
                    NSLog( @"Moved with <%d> touch responder(s)", _touchList.count );
                    if ( [ touchEntry.node respondsToSelector:@selector( touchesMoved:withEvent: ) ] == YES )
                        [ touchEntry.node touchesMoved:[ NSSet setWithObject:touch ] withEvent:event ];
                }
            }
        } else {
        
            // scan backwards through touch responders
            for ( int index = _responderCount - 1; index >= 0; index -- ) {
                CCNode* node = _responderList[ index ];
            
                // if the touch responder does not lock touch, it will receive a touchesBegan if a touch is moved inside
                if ( ( node.isTouchLocked == NO ) && ( [ node hitTestWithTouch:touch ] == YES ) ) {
                    
                    // begin the touch
                    self.touchProcessed = YES;
                    NSLog( @"Began with <%d> touch responder(s)", _touchList.count );
                    if ( [ node respondsToSelector:@selector( touchesBegan:withEvent: ) ] == YES )
                        [ node touchesBegan:[ NSSet setWithObject:touch ] withEvent:event ];
                    
                    // if touch was accepted, add it and break
                    if ( self.touchProcessed == YES ) {

                        [ self addtouchResponder:node withTouch:touch andEvent:event ];
                        break;
                    }
                }
            }
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesEnded:( NSSet* )touches withEvent:( UIEvent* )event {
    
    [ self buildTouchResponderList ];

    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouch* touchEntry = [ self touchResponderForEvent:event ];
        
        if ( touchEntry != nil ) {
        
            // end the touch
            NSLog( @"Ended with <%d> touch responder(s)", _touchList.count );
            if ( [ touchEntry.node respondsToSelector:@selector( touchesEnded:withEvent: ) ] == YES )
                [ touchEntry.node touchesEnded:[ NSSet setWithObject:touch ] withEvent:event ];
            // remove from list
            [ _touchList removeObject:touchEntry ];
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesCancelled:( NSSet* )touches withEvent:( UIEvent* )event {
    
    [ self buildTouchResponderList ];

    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouch* touchEntry = [ self touchResponderForEvent:event ];
        
        if ( touchEntry != nil ) {
            
            // cancel the touch
            NSLog( @"Cancelled with <%d> touch responder(s)", _touchList.count );
            if ( [ touchEntry.node respondsToSelector:@selector( touchesCancelled:withEvent: ) ] == YES )
                [ touchEntry.node touchesCancelled:[ NSSet setWithObject:touch ] withEvent:event ];
            // remove from list
            [ _touchList removeObject:touchEntry ];
        }
    }
}

// -----------------------------------------------------------------
#pragma mark - helper functions
// -----------------------------------------------------------------
// finds a touch object for an event

-( CCTouch* )touchResponderForEvent:( UIEvent* )event {
    for ( CCTouch* touchEntry in _touchList ) {
        if ( touchEntry.event == event ) return( touchEntry );
    }
    return( nil );
}

// -----------------------------------------------------------------
// finds a touch object for a node

-( NSSet* )touchSetForNode:( CCNode* )node {
    NSMutableSet* result = [ NSMutableSet set ];
    for ( CCTouch* touchEntry in _touchList ) {
        if ( touchEntry.node == node ) [ result addObject:touchEntry.touch ];
    }
    return( result );
}

// -----------------------------------------------------------------
// adds a touch object ( running touch ) to the touch object list

-( void )addtouchResponder:( CCNode* )node withTouch:( UITouch* )touch andEvent:( UIEvent* )event {
    CCTouch* touchEntry;
    
    // create a new touch object
    touchEntry = [ [ CCTouch alloc ] init ];
    touchEntry.node = node;
    touchEntry.touch = touch;
    touchEntry.event = event;
    [ _touchList addObject:touchEntry ];
}

// -----------------------------------------------------------------

-( void )buildTouchResponderList {
    
    // rebuild touch list
    // TODO: only rebuild if dirty
    [ self removeAllTouchResponders ];
    [ [ CCDirector sharedDirector ].runningScene buildTouchResponderList ];
}

// -----------------------------------------------------------------

@end










































