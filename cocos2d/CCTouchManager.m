/*
 * cocos2d for iPhone: http://www.cocos2d-iphone.org
 *
 * Copyright (c) 2010 Ricardo Quesada
 * Copyright (c) 2011 Zynga Inc.
 * Copyright (c) 2013 Lars Birkemose
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * File autogenerated with Xcode. Adapted for cocos2d needs.
 */

#import "CCTouchManager.h"
#import "CCNode.h"

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouchObject

@end

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouchManager {
    __weak CCNode*          _touchBuffer[ CCTouchManagerTouchBufferSize ];
    int                     _touchBufferCount;
    NSMutableArray*         _touchList;
}

// -----------------------------------------------------------------
#pragma mark - create and destroy
// -----------------------------------------------------------------

+( id )touchManager {
    return( [ [ self alloc ] init ] );
}

-( id )init {
    self = [ super init ];
    NSAssert( self != nil, @"Unable to create class" );

    // initalize
    _touchList = [ NSMutableArray array ];
    
    // reset touch handling
    [ self removeAllTouchReceivers ];
    
    // done
    return( self );
}

// -----------------------------------------------------------------
#pragma mark - add and remove touch receivers
// -----------------------------------------------------------------

-( void )addTouchReceiver:( CCNode* )receiver {
    _touchBuffer[ _touchBufferCount ] = receiver;
    _touchBufferCount ++;
    NSAssert( _touchBufferCount < CCTouchManagerTouchBufferSize, @"Number of touchable nodes pr. scene can not exceed <%d>", CCTouchManagerTouchBufferSize );
}

-( void )removeAllTouchReceivers {
    _touchBufferCount = 0;
}

// -----------------------------------------------------------------
#pragma mark - internal
// -----------------------------------------------------------------

-( CCTouchObject* )touchObjectForEvent:( UIEvent* )event {
    for ( CCTouchObject* touchObject in _touchList ) {
        if ( touchObject.event == event ) return( touchObject );
    }
    return( nil );
}

// -----------------------------------------------------------------

-( void )touchesBegan:( NSSet* )touches withEvent:( UIEvent* )event {

    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // scan backwards through touch receivers
        for ( int index = _touchBufferCount - 1; index >= 0; index -- ) {
            
            // check for hit test
            if ( [ _touchBuffer[ index ] hitTestWithTouch:touch ] == YES ) {
                
                // create a new touch entry
                CCTouchObject* touchObject = [ [ CCTouchObject alloc ] init ];
                touchObject.event = event;
                touchObject.target = _touchBuffer[ index ];
                [ _touchList addObject:touchObject ];
                
                // begin the touch
                NSLog( @"Began with <%d> touch receiver(s)", _touchList.count );
                if ( [ touchObject.target respondsToSelector:@selector( touchesBegan:withEvent: ) ] == YES )
                    [ touchObject.target performSelector:@selector( touchesBegan:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];

                // no more touches
                break;
            }
        }
    }
}

-( void )touchesMoved:( NSSet* )touches withEvent:( UIEvent* )event {
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        // if a touch object was found
        if ( touchObject != nil ) {
            
            // check if it locks touches
            if ( touchObject.target.isTouchLocked == YES ) {
                
                // move the touch
                NSLog( @"Moved with <%d> touch receiver(s)", _touchList.count );
                if ( [ touchObject.target respondsToSelector:@selector( touchesMoved:withEvent: ) ] == YES )
                    [ touchObject.target performSelector:@selector( touchesMoved:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
                
            } else {
            
                // as node does not lock touch, check if it was moved outside
                if ( [ touchObject.target hitTestWithTouch:touch ] == NO ) {
                
                    // cancel the touch
                    NSLog( @"Cancelled with <%d> touch receiver(s)", _touchList.count );
                    if ( [ touchObject.target respondsToSelector:@selector( touchesCancelled:withEvent: ) ] == YES )
                        [ touchObject.target performSelector:@selector( touchesCancelled:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
                    // remove from list
                    [ _touchList removeObject:touchObject ];
                
                } else {
                
                    // move the touch
                    NSLog( @"Moved with <%d> touch receiver(s)", _touchList.count );
                    if ( [ touchObject.target respondsToSelector:@selector( touchesMoved:withEvent: ) ] == YES )
                        [ touchObject.target performSelector:@selector( touchesMoved:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
                }
            }
        } else {
        
            // scan backwards through touch receivers
            for ( int index = _touchBufferCount - 1; index >= 0; index -- ) {
            
                // if the touch receives does not lock touch, it will receive a touchesBegan if a touch is moved inside
                if ( ( _touchBuffer[ index ].isTouchLocked == NO ) && ( [ _touchBuffer[ index ] hitTestWithTouch:touch ] == YES ) ) {
                
                    // create a new touch entry
                    touchObject = [ [ CCTouchObject alloc ] init ];
                    touchObject.event = event;
                    touchObject.target = _touchBuffer[ index ];
                    [ _touchList addObject:touchObject ];
                    
                    // begin the touch
                    NSLog( @"Began with <%d> touch receiver(s)", _touchList.count );
                    if ( [ touchObject.target respondsToSelector:@selector( touchesBegan:withEvent: ) ] == YES )
                        [ touchObject.target performSelector:@selector( touchesBegan:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
                    
                    // no more touches
                    break;
                }
            }
        }
    }
}

-( void )touchesEnded:( NSSet* )touches withEvent:( UIEvent* )event {
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        if ( touchObject != nil ) {
        
            // end the touch
            NSLog( @"Ended with <%d> touch receiver(s)", _touchList.count );
            if ( [ touchObject.target respondsToSelector:@selector( touchesEnded:withEvent: ) ] == YES )
                [ touchObject.target performSelector:@selector( touchesEnded:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
            // remove from list
            [ _touchList removeObject:touchObject ];
        }
    }
}

-( void )touchesCancelled:( NSSet* )touches withEvent:( UIEvent* )event {
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        if ( touchObject != nil ) {
            
            // cancel the touch
            NSLog( @"Cancelled with <%d> touch receiver(s)", _touchList.count );
            if ( [ touchObject.target respondsToSelector:@selector( touchesCancelled:withEvent: ) ] == YES )
                [ touchObject.target performSelector:@selector( touchesCancelled:withEvent: ) withObject:[ NSSet setWithObject:touch ] withObject:event ];
            // remove from list
            [ _touchList removeObject:touchObject ];
        }
    }
}

// -----------------------------------------------------------------

@end










































