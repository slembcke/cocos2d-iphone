/*
 * cocos2d for iPhone: http://www.cocos2d-iphone.org
 *
 * Copyright (c) 2010 Ricardo Quesada
 * Copyright (c) 2011 Zynga Inc.
 * Copyright (c) 2013 Lars Birkemose
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *
 * File autogenerated with Xcode. Adapted for cocos2d needs.
 */

#import "CCTouchManager.h"
#import "CCNode.h"
#import "CCDirector.h"

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouchObject

@end

// -----------------------------------------------------------------
#pragma mark -
// -----------------------------------------------------------------

@implementation CCTouchManager {
    __weak CCNode*          _touchBuffer[ CCTouchManagerTouchBufferSize ];
    int                     _touchBufferCount;
    NSMutableArray*         _touchList;
}

// -----------------------------------------------------------------
#pragma mark - create and destroy
// -----------------------------------------------------------------

+( id )touchManager {
    return( [ [ self alloc ] init ] );
}

-( id )init {
    self = [ super init ];
    NSAssert( self != nil, @"Unable to create class" );
    
    // initalize
    _touchList = [ NSMutableArray array ];
        
    // reset touch handling
    [ self removeAllTouchReceivers ];
    
    // done
    return( self );
}

// -----------------------------------------------------------------
#pragma mark - add and remove touch receivers
// -----------------------------------------------------------------

-( void )addTouchReceiver:( CCNode* )receiver {
    _touchBuffer[ _touchBufferCount ] = receiver;
    _touchBufferCount ++;
    NSAssert( _touchBufferCount < CCTouchManagerTouchBufferSize, @"Number of touchable nodes pr. scene can not exceed <%d>", CCTouchManagerTouchBufferSize );
}

-( void )removeAllTouchReceivers {
    _touchBufferCount = 0;
}

// -----------------------------------------------------------------
#pragma mark - internal
// -----------------------------------------------------------------

-( void )touchesBegan:( NSSet* )touches withEvent:( UIEvent* )event {
    BOOL receiverCanNotAcceptTouch;
    BOOL receiverProcessedTouch;
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // scan backwards through touch receivers
        for ( int index = _touchBufferCount - 1; index >= 0; index -- ) {
            CCNode* node = _touchBuffer[ index ];
            
            // check for hit test
            if ( [ node hitTestWithTouch:touch ] == YES ) {
                
                // if not a multi touch node, check if node already is being touched
                receiverCanNotAcceptTouch = NO;
                if ( node.isMultipleTouchEnabled == NO ) {
                
                    // scan current touch objects, and break if object already has a touch
                    for ( CCTouchObject* touchObject in _touchList ) if ( touchObject.target == node ) {
                        receiverCanNotAcceptTouch = YES;
                        break;
                    }
                }                
                if ( receiverCanNotAcceptTouch == YES ) break;
                
                // begin the touch
                receiverProcessedTouch = YES;
                NSLog( @"Began with <%d> touch receiver(s)", _touchList.count );
                if ( [ node respondsToSelector:@selector( touchBegan:withEvent: ) ] == YES )
                    receiverProcessedTouch = [ node touchBegan:touch withEvent:event ];
 
                // if touch was accepted, add it and break
                if ( receiverProcessedTouch == YES ) {
                    
                    [ self addTouchObject:node withEvent:event ];
                    break;
                }
            }
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesMoved:( NSSet* )touches withEvent:( UIEvent* )event {
    BOOL receiverProcessedTouch;
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        // if a touch object was found
        if ( touchObject != nil ) {
            
            // check if it locks touches
            if ( touchObject.target.isTouchLocked == YES ) {
                
                // move the touch
                NSLog( @"Moved with <%d> touch receiver(s)", _touchList.count );
                if ( [ touchObject.target respondsToSelector:@selector( touchMoved:withEvent: ) ] == YES )
                    [ touchObject.target touchMoved:touch withEvent:event ];
                
            } else {
            
                // as node does not lock touch, check if it was moved outside
                if ( [ touchObject.target hitTestWithTouch:touch ] == NO ) {
                
                    // cancel the touch
                    NSLog( @"Cancelled with <%d> touch receiver(s)", _touchList.count );
                    if ( [ touchObject.target respondsToSelector:@selector( touchCancelled:withEvent: ) ] == YES )
                        [ touchObject.target touchCancelled:touch withEvent:event ];
                    // remove from list
                    [ _touchList removeObject:touchObject ];
                
                } else {
                
                    // move the touch
                    NSLog( @"Moved with <%d> touch receiver(s)", _touchList.count );
                    if ( [ touchObject.target respondsToSelector:@selector( touchMoved:withEvent: ) ] == YES )
                        [ touchObject.target touchMoved:touch withEvent:event ];
                }
            }
        } else {
        
            // scan backwards through touch receivers
            for ( int index = _touchBufferCount - 1; index >= 0; index -- ) {
                CCNode* node = _touchBuffer[ index ];
            
                // if the touch receives does not lock touch, it will receive a touchBegan if a touch is moved inside
                if ( ( node.isTouchLocked == NO ) && ( [ node hitTestWithTouch:touch ] == YES ) ) {
                    
                    // begin the touch
                    receiverProcessedTouch = YES;
                    NSLog( @"Began with <%d> touch receiver(s)", _touchList.count );
                    if ( [ node respondsToSelector:@selector( touchBegan:withEvent: ) ] == YES )
                        receiverProcessedTouch = [ node touchBegan:touch withEvent:event ];
                    
                    // if touch was accepted, add it and break
                    if ( receiverProcessedTouch == YES ) {

                        [ self addTouchObject:node withEvent:event ];
                        break;
                    }
                }
            }
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesEnded:( NSSet* )touches withEvent:( UIEvent* )event {
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        if ( touchObject != nil ) {
        
            // end the touch
            NSLog( @"Ended with <%d> touch receiver(s)", _touchList.count );
            if ( [ touchObject.target respondsToSelector:@selector( touchEnded:withEvent: ) ] == YES )
                [ touchObject.target touchEnded:touch withEvent:event ];
            // remove from list
            [ _touchList removeObject:touchObject ];
        }
    }
}

// -----------------------------------------------------------------

-( void )touchesCancelled:( NSSet* )touches withEvent:( UIEvent* )event {
    
    // go through all touches
    for ( UITouch* touch in touches ) {
        
        // get touch object
        CCTouchObject* touchObject = [ self touchObjectForEvent:event ];
        
        if ( touchObject != nil ) {
            
            // cancel the touch
            NSLog( @"Cancelled with <%d> touch receiver(s)", _touchList.count );
            if ( [ touchObject.target respondsToSelector:@selector( touchCancelled:withEvent: ) ] == YES )
                [ touchObject.target touchCancelled:touch withEvent:event ];
            // remove from list
            [ _touchList removeObject:touchObject ];
        }
    }
}

// -----------------------------------------------------------------
#pragma mark - internal helper functions
// -----------------------------------------------------------------
// finds a touch object for an event

-( CCTouchObject* )touchObjectForEvent:( UIEvent* )event {
    for ( CCTouchObject* touchObject in _touchList ) {
        if ( touchObject.event == event ) return( touchObject );
    }
    return( nil );
}

// -----------------------------------------------------------------
// adds a touch object ( running touch ) to the touch object list

-( void )addTouchObject:( CCNode* )node withEvent:( UIEvent* )event {
    CCTouchObject* touchObject;
    
    // create a new touch object
    touchObject = [ [ CCTouchObject alloc ] init ];
    touchObject.target = node;
    touchObject.event = event;
    [ _touchList addObject:touchObject ];
}

// -----------------------------------------------------------------

@end










































